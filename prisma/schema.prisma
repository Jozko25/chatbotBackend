generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ============================================
// USER MANAGEMENT
// ============================================

model User {
  id            String    @id @default(cuid())
  auth0Sub      String    @unique @map("auth0_sub")
  email         String    @unique
  name          String?
  avatarUrl     String?   @map("avatar_url")

  // Subscription & limits
  plan          Plan      @default(FREE)
  messageLimit  Int       @default(100) @map("message_limit")
  messagesUsed  Int       @default(0) @map("messages_used")
  limitResetAt  DateTime  @default(now()) @map("limit_reset_at")

  // Timestamps
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")
  lastLoginAt   DateTime? @map("last_login_at")

  // Relations
  chatbots      Chatbot[]
  apiKeys       ApiKey[]
  usageRecords  UsageRecord[]

  @@map("users")
}

enum Plan {
  FREE
  STARTER
  PRO
  ENTERPRISE
}

// ============================================
// CHATBOT INSTANCES
// ============================================

model Chatbot {
  id              String    @id @default(cuid())
  userId          String    @map("user_id")

  // Scraped website data
  name            String
  sourceUrl       String    @map("source_url")
  clinicData      Json      @map("clinic_data")
  rawContent      String?   @map("raw_content") @db.Text

  // Theme/customization
  theme           Json      @default("{}")

  // Status
  status          ChatbotStatus @default(ACTIVE)
  lastScrapedAt   DateTime  @map("last_scraped_at")

  // Timestamps
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")

  // Relations
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  conversations   Conversation[]
  apiKeys         ApiKey[]
  usageRecords    UsageRecord[]

  @@index([userId])
  @@index([sourceUrl])
  @@map("chatbots")
}

enum ChatbotStatus {
  ACTIVE
  PAUSED
  DELETED
}

// ============================================
// CONVERSATIONS & MESSAGES
// ============================================

model Conversation {
  id            String    @id @default(cuid())
  chatbotId     String    @map("chatbot_id")

  // Session tracking (for embed widget)
  sessionId     String    @map("session_id")
  visitorIp     String?   @map("visitor_ip")
  visitorUserAgent String? @map("visitor_user_agent") @db.Text
  referrerUrl   String?   @map("referrer_url")

  // Timestamps
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  // Relations
  chatbot       Chatbot   @relation(fields: [chatbotId], references: [id], onDelete: Cascade)
  messages      Message[]

  @@unique([chatbotId, sessionId])
  @@index([chatbotId])
  @@index([sessionId])
  @@map("conversations")
}

model Message {
  id              String    @id @default(cuid())
  conversationId  String    @map("conversation_id")

  role            MessageRole
  content         String    @db.Text

  // Token usage tracking
  promptTokens    Int?      @map("prompt_tokens")
  completionTokens Int?     @map("completion_tokens")

  // Timestamps
  createdAt       DateTime  @default(now()) @map("created_at")

  // Relations
  conversation    Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@map("messages")
}

enum MessageRole {
  user
  assistant
  system
}

// ============================================
// API KEYS (for embed widget authentication)
// ============================================

model ApiKey {
  id            String    @id @default(cuid())
  userId        String    @map("user_id")
  chatbotId     String?   @map("chatbot_id")

  // Key data (store hashed, return prefix only)
  keyHash       String    @unique @map("key_hash")
  keyPrefix     String    @map("key_prefix")
  name          String    @default("Default Key")

  // Domain whitelist for security
  allowedDomains String[] @default([]) @map("allowed_domains")

  // Permissions & limits
  scopes        String[]  @default(["chat"])
  rateLimit     Int       @default(60) @map("rate_limit")

  // Status
  isActive      Boolean   @default(true) @map("is_active")
  lastUsedAt    DateTime? @map("last_used_at")
  expiresAt     DateTime? @map("expires_at")

  // Timestamps
  createdAt     DateTime  @default(now()) @map("created_at")

  // Relations
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  chatbot       Chatbot?  @relation(fields: [chatbotId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([chatbotId])
  @@map("api_keys")
}

// ============================================
// USAGE TRACKING & ANALYTICS
// ============================================

model UsageRecord {
  id            String    @id @default(cuid())
  userId        String    @map("user_id")
  chatbotId     String?   @map("chatbot_id")

  // Event data
  eventType     UsageEventType @map("event_type")

  // For message events
  promptTokens    Int?    @map("prompt_tokens")
  completionTokens Int?   @map("completion_tokens")

  // Timestamps
  createdAt     DateTime  @default(now()) @map("created_at")

  // Date partition for efficient querying
  date          DateTime  @db.Date

  // Relations
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  chatbot       Chatbot?  @relation(fields: [chatbotId], references: [id], onDelete: Cascade)

  @@index([userId, date])
  @@index([chatbotId, date])
  @@index([eventType, date])
  @@map("usage_records")
}

enum UsageEventType {
  SCRAPE
  CHAT_MESSAGE
  EMBED_COPY
  WIDGET_LOAD
}
